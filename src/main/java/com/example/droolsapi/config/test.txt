# ===== ADHD Rule — PySpark (copy-paste) =====
# Inputs expected in the Snowflake table:
# INDV_ID, AGE, ELEM_NBR, MEM_NAME, ELEM_QTY, ELEM_SUP,
# CONTINUITY, CONTINUOUS_PERIOD (or GRACE_PERIOD), 
# EFFECTIVE_DATE, MAX_END_DATE, FINAL_END_DATE, MIN_EFF_DATE,
# ELEM_DT_1, ELEM_DT_2

from pyspark.sql import functions as F
from pyspark.sql.window import Window

# ---------- 0) Snowflake read ----------
snowflake_options = {
    "sfURL":       "<account>.snowflakecomputing.com",
    "sfUser":      "<user>",
    "sfPassword":  "<password>",
    "sfDatabase":  "<DB>",
    "sfSchema":    "<SCHEMA>",
    "sfWarehouse": "<WH>",
    "sfRole":      "<ROLE>",
}

SOURCE_TABLE = "ELEMENT_DATA_TABLE_KIS"   # change if needed

df = (spark.read.format("snowflake")
      .options(**snowflake_options)
      .option("dbtable", SOURCE_TABLE)
      .load()
      .select(
          "INDV_ID","AGE","ELEM_NBR","MEM_NAME","ELEM_QTY","ELEM_SUP",
          "CONTINUITY","CONTINUOUS_PERIOD","GRACE_PERIOD",
          "EFFECTIVE_DATE","MAX_END_DATE","FINAL_END_DATE","MIN_EFF_DATE",
          "ELEM_DT_1","ELEM_DT_2"
      ))

# Map Java getContinuousPeriod(): if CONTINUOUS_PERIOD missing but GRACE_PERIOD present, use it
df = df.withColumn(
    "CONTINUOUS_PERIOD",
    F.coalesce(F.col("CONTINUOUS_PERIOD"), F.col("GRACE_PERIOD"))
)

# ---------- 1) Derived columns (mirror Java getters) ----------

# 1a) getPdcNumeratorInDays(): if elem_sup starts with "PHARM 2", take Java substring(15,18)
# Spark substring is 1-based, length-based -> (start=16, length=3)
pdc_base = F.when(
    (F.col("ELEM_SUP").isNotNull()) & (F.length("ELEM_SUP") > 18) &
    (F.substring("ELEM_SUP", 1, 7) == F.lit("PHARM 2")),
    F.substring("ELEM_SUP", 16, 3)
)
pdc_digits = F.regexp_replace(pdc_base, r"[^0-9-]", "")
df = df.withColumn(
    "PDC_NUMERATOR_IN_DAYS",
    F.when(F.length(pdc_digits) > 0, pdc_digits.cast("int"))
)

# 1b) getAdjustedFinalDate(): only when EFFECTIVE_DATE > MAX_END_DATE and both FINAL_END_DATE, MIN_EFF_DATE present
df = df.withColumn(
    "ADJUSTED_FINAL_DATE",
    F.when(
        (F.col("EFFECTIVE_DATE").isNotNull()) &
        (F.col("MAX_END_DATE").isNotNull()) &
        (F.col("EFFECTIVE_DATE") > F.col("MAX_END_DATE")) &
        F.col("FINAL_END_DATE").isNotNull() &
        F.col("MIN_EFF_DATE").isNotNull(),
        F.datediff(F.col("FINAL_END_DATE"), F.col("MIN_EFF_DATE"))
    )
)

# 1c) getIsElemDt2XDays(): daysBetween(elem_dt_2, todayMinus43)
today_minus_43 = F.date_sub(F.current_date(), 43)
df = df.withColumn(
    "IS_ELEM_DT_2X_DAYS",
    F.when(F.col("ELEM_DT_2").isNotNull(), F.datediff(today_minus_43, F.to_date("ELEM_DT_2")))
)

# ---------- 2) Feature flags per INDV_ID (EXISTS/NOT EXISTS in one agg) ----------
feat = (
    df.groupBy("INDV_ID").agg(
        # $sdm: age ∈ [6,12)
        F.max(F.when((F.col("AGE") >= 6) & (F.col("AGE") < 12), 1).otherwise(0)).alias("sdm_exists"),

        # $pharm: elem=2563, PHARM, pdc>=210
        F.max(F.when(
            (F.col("ELEM_NBR") == 2563) &
            (F.col("MEM_NAME") == "INDV_ELEMENTS_PHARM") &
            (F.col("PDC_NUMERATOR_IN_DAYS") >= 210),
            1).otherwise(0)
        ).alias("pharm_exists"),

        # continuity gate: (continuousPeriod>=320 && "3650_Continuous") OR (adjustedFinalDate>=320 && "3650_Continuous")
        F.max(F.when(
            ((F.col("CONTINUOUS_PERIOD") >= 320) & (F.col("CONTINUITY") == "3650_Continuous")) |
            ((F.col("ADJUSTED_FINAL_DATE") >= 320) & (F.col("CONTINUITY") == "3650_Continuous")),
            1).otherwise(0)
        ).alias("has_continuous_condition"),

        # must have 3018 + ATTR_EG
        F.max(F.when(
            (F.col("ELEM_NBR") == 3018) & (F.col("MEM_NAME") == "INDV_ELEMENTS_ATTR_EG"),
            1).otherwise(0)
        ).alias("has_3018_ATTR_EG"),

        # forbid ADJ/PREADJ in last 365 via dt2
        F.max(F.when(
            (
                ((F.col("ELEM_NBR") == 2575) & (F.col("MEM_NAME") == "INDV_ELEMENTS_ADJ")) |
                ((F.col("ELEM_NBR") == 2576) & (F.col("MEM_NAME") == "INDV_ELEMENTS_PREADJ"))
            ) &
            (F.col("IS_ELEM_DT_2X_DAYS") >= 0) & (F.col("IS_ELEM_DT_2X_DAYS") <= 365),
            1).otherwise(0)
        ).alias("has_forbidden_adj_preadj"),

        # forbid {3048,3159,3010} + ATTR_EG
        F.max(F.when(
            (F.col("MEM_NAME") == "INDV_ELEMENTS_ATTR_EG") &
            (F.col("ELEM_NBR").isin(3048, 3159, 3010)),
            1).otherwise(0)
        ).alias("has_forbidden_attr_eg_set")
    )
)

# ---------- 3) Choose one $pharm row per INDV_ID (for THEN block) ----------
pharm_rows = df.filter(
    (F.col("ELEM_NBR") == 2563) &
    (F.col("MEM_NAME") == "INDV_ELEMENTS_PHARM") &
    (F.col("PDC_NUMERATOR_IN_DAYS") >= 210)
).select("INDV_ID", "ELEM_SUP")

# Prefer startswith("PHARM 2"), then longest elem_sup
pharm_ranked = (pharm_rows
                .withColumn("is_pharm2", F.col("ELEM_SUP").startswith("PHARM 2").cast("int"))
                .withColumn("len_sup", F.length("ELEM_SUP")))
w = Window.partitionBy("INDV_ID").orderBy(F.col("is_pharm2").desc(), F.col("len_sup").desc())
pharm_one = (pharm_ranked
             .withColumn("rn", F.row_number().over(w))
             .filter("rn = 1")
             .drop("rn", "is_pharm2", "len_sup"))

# ---------- 4) THEN block (exact Java mapping) ----------
startsWithPharm2 = F.col("ELEM_SUP").isNotNull() & F.col("ELEM_SUP").startswith("PHARM 2")
len_ge_152 = (F.length("ELEM_SUP") >= 152)
len_ge_131 = (F.length("ELEM_SUP") >= 131)

# Java substring(93,103)->Spark substring(94,10); (115,125)->(116,10)
s93_103  = F.substring("ELEM_SUP", 94, 10)
s115_125 = F.substring("ELEM_SUP", 116, 10)

to_num = lambda s: F.when(
    F.length(F.regexp_replace(s, r"[^0-9.-]", "")) > 0,
    F.regexp_replace(s, r"[^0-9.-]", "").cast("double")
)

score1Desc = F.when(len_ge_152, F.lit("RXMD"))
score1Nbr  = F.when(len_ge_152, to_num(s93_103))

flag115 = F.when(len_ge_131, F.substring("ELEM_SUP", 115, 1))
flag131 = F.when(len_ge_131, F.substring("ELEM_SUP", 131, 1))
empty = F.lit("")

score2Desc = (
    F.when(flag115 == empty, F.lit("MXRXMD"))
     .when((flag115.isNotNull()) & (flag115 != empty) & (flag115 != F.lit("B")) & (flag131 == empty), F.lit("MXRXMD"))
)
score2Nbr = (
    F.when(flag115 == empty, to_num(s93_103))
     .when((flag115.isNotNull()) & (flag115 != empty) & (flag115 != F.lit("B")) & (flag131 == empty), to_num(s115_125))
)
score3Desc = (
    F.when(flag115 == F.lit("B"), F.lit("BHRXMD"))
     .when((flag115.isNotNull()) & (flag115 != empty) & (flag115 != F.lit("B")) & (flag131 == F.lit("B")), F.lit("BHRXMD"))
)
score3Nbr = (
    F.when(flag115 == F.lit("B"), to_num(s93_103))
     .when((flag115.isNotNull()) & (flag115 != empty) & (flag115 != F.lit("B")) & (flag131 == F.lit("B")), to_num(s115_125))
)

then_cols = (pharm_one
             .withColumn("startsWithPharm2", startsWithPharm2)
             .withColumn("score1Desc", score1Desc)
             .withColumn("score1Nbr",  score1Nbr)
             .withColumn("score2Desc", score2Desc)
             .withColumn("score2Nbr",  score2Nbr)
             .withColumn("score3Desc", score3Desc)
             .withColumn("score3Nbr",  score3Nbr)
             .select("INDV_ID","startsWithPharm2","score1Desc","score1Nbr","score2Desc","score2Nbr","score3Desc","score3Nbr"))

# ---------- 5) Rule gates ----------
rule_pass = (
    (F.col("sdm_exists") == 1) &
    (F.col("pharm_exists") == 1) &
    (F.col("has_continuous_condition") == 1) &
    (F.col("has_3018_ATTR_EG") == 1) &
    (F.col("has_forbidden_adj_preadj") == 0) &
    (F.col("has_forbidden_attr_eg_set") == 0)
)

# ---------- 6) Final STATUS (prints 'null' text like Java ternaries) ----------
joined = feat.join(then_cols, on="INDV_ID", how="left")
s = lambda c: F.when(F.col(c).isNotNull(), F.col(c).cast("string")).otherwise(F.lit("null"))

status = F.concat_ws(
    "",
    F.lit("TPOBEH001; "),
    s("score1Desc"), F.lit(" ; "), s("score1Nbr"),  F.lit(" ; "),
    s("score2Desc"), F.lit(" ; "), s("score2Nbr"),  F.lit(" ; "),
    s("score3Desc"), F.lit(" ; "), s("score3Nbr")
)

result = (joined
          .filter(rule_pass & F.col("startsWithPharm2"))
          .select("INDV_ID", status.alias("STATUS")))

# ---------- 7) Preview / (optional) write back ----------
result.show(100, truncate=False)

# Optional write to Snowflake:
# (uncomment & set your target table)
# (result.write.format("snowflake")
#        .options(**snowflake_options)
#        .option("dbtable", "STREAMLIT_RESULTS_KIS")
#        .mode("append")
#        .save())
