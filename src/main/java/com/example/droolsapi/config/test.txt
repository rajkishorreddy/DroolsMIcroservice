%scala
import org.kie.api.KieServices
import org.kie.api.builder.{KieBuilder, Message, Results}
import org.kie.api.runtime.StatelessKieSession
import org.kie.internal.io.ResourceFactory

case class InputRow(indvId: Long, amount: Double)
case class OutputRow(indvId: Long, ruleNum: String, ruleFlag: String, isActive: Boolean)

// reuse the drlBody you already loaded above
val drlBC = spark.sparkContext.broadcast(drlBody)

// build Drools session on executors (with verbose errors)
def buildSessionVerboseOnExec(drl: String): StatelessKieSession = {
  val ks  = KieServices.Factory.get
  val kfs = ks.newKieFileSystem()
  kfs.write(ResourceFactory.newByteArrayResource(drl.getBytes("UTF-8"))
    .setSourcePath("rules/sample.drl"))
  val kb: KieBuilder = ks.newKieBuilder(kfs).buildAll()
  val res: Results = kb.getResults
  if (res.hasMessages(Message.Level.ERROR)) {
    val it = res.getMessages(Message.Level.ERROR).iterator()
    val sb = new StringBuilder("DROOLS BUILD ERRORS (executor):\n")
    while (it.hasNext) sb.append("  ").append(it.next().toString).append("\n")
    throw new IllegalStateException(sb.toString)
  }
  ks.newKieContainer(ks.getRepository.getDefaultReleaseId)
    .getKieBase.newStatelessKieSession()
}

// tiny demo input (one should fire)
import spark.implicits._
val df = Seq(
  InputRow(101, 500.0),     // should NOT fire
  InputRow(102, 1200.5),    // should fire
  InputRow(103, 50.0)       // should NOT fire
).toDF

// run per-partition (compile once per executor)
val out = df.mapPartitions { it =>
  lazy val session: StatelessKieSession = buildSessionVerboseOnExec(drlBC.value)

  it.map { r =>
    val fact   = new java.util.HashMap[String,Object]()
    fact.put("indvId", r.getAs[Long]("indvId").asInstanceOf[java.lang.Long])
    fact.put("amount", r.getAs[Double]("amount").asInstanceOf[java.lang.Double])

    val result = new java.util.HashMap[String,Object]()
    session.setGlobal("result", result)

    val facts = new java.util.ArrayList[Object]()
    facts.add(fact); facts.add(result)

    try session.execute(facts)
    catch { case e: Throwable =>
      throw new RuntimeException(s"Rule execution failed for fact=$fact", e)
    }

    val ruleNum  = Option(result.get("ruleNum")).map(_.toString).getOrElse("NA")
    val ruleFlag = Option(result.get("ruleFlag")).map(_.toString).getOrElse("N")
    val isActive = Option(result.get("isActive")).exists(_.toString.equalsIgnoreCase("true"))

    OutputRow(r.getAs[Long]("indvId"), ruleNum, ruleFlag, isActive)
  }
}.toDF

out.show(false)
