// ====== Fixed helpers ======
def gi(r: Row, name: String): java.lang.Integer =
  Option(r.getAs[java.math.BigDecimal](name))
    .map(_.intValue())
    .orElse(Option(r.getAs[java.lang.Integer](name)))
    .getOrElse(null.asInstanceOf[java.lang.Integer])

def gl(r: Row, name: String): java.lang.Long =
  Option(r.getAs[java.math.BigDecimal](name))
    .map(_.longValue())
    .orElse(Option(r.getAs[java.lang.Long](name)))
    .getOrElse(null.asInstanceOf[java.lang.Long])

def gd(r: Row, name: String): java.lang.Double =
  Option(r.getAs[java.lang.Double](name))
    .orElse(Option(r.getAs[java.math.BigDecimal](name)).map(_.doubleValue()))
    .getOrElse(null.asInstanceOf[java.lang.Double])

def gf(r: Row, name: String): java.lang.Float =
  Option(r.getAs[java.lang.Float](name))
    .orElse(Option(r.getAs[java.lang.Double](name)).map(_.toFloat))
    .orElse(Option(r.getAs[java.math.BigDecimal](name)).map(_.floatValue()))
    .getOrElse(null.asInstanceOf[java.lang.Float])

def gs(r: Row, name: String): String =
  Option(r.getAs[String](name)).getOrElse(null.asInstanceOf[String])

def gdate(r: Row, name: String): java.sql.Date = {
  val d1 = Option(r.getAs[java.sql.Date](name))
  val d2 = Option(r.getAs[java.time.LocalDate](name)).map(java.sql.Date.valueOf)
  val d3 = Option(r.getAs[String](name)).map(java.sql.Date.valueOf)
  d1.orElse(d2).orElse(d3).getOrElse(null.asInstanceOf[java.sql.Date])
}

// ===== Group + Fire test again =====
val outs = testFacts.groupBy(_.getIndv_id()).toSeq.flatMap { case (_, facts) => fire(facts) }
println(s"ğŸ”¥ Fired groups: ${outs.size}")
outs.take(10).foreach(println)
