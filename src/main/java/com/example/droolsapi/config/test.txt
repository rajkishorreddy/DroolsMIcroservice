%scala
import org.kie.api.KieServices
import org.kie.api.builder.{KieBuilder, Message}
import org.kie.internal.io.ResourceFactory
import org.kie.api.runtime.KieSession
import org.kie.api.runtime.rule.ClassObjectFilter

val drlPath = "/dbfs/FileStore/rules/AdolescentImmuneRule.drl"
val drlBody = scala.io.Source.fromFile(new java.io.File(drlPath), "UTF-8").mkString

def buildKieBaseVerbose(drl: String) = {
  val ks  = KieServices.Factory.get
  val kfs = ks.newKieFileSystem()
  kfs.write(
    ResourceFactory
      .newByteArrayResource(drl.getBytes("UTF-8"))
      .setSourcePath("rules/AdolescentImmuneRule.drl")
  )
  val kb: KieBuilder = ks.newKieBuilder(kfs).buildAll()
  val res = kb.getResults
  if (res.hasMessages(Message.Level.ERROR)) {
    println("===== DROOLS BUILD ERRORS =====")
    res.getMessages(Message.Level.ERROR).forEach(m => println("  " + m))
    throw new IllegalStateException("DRL failed to compile")
  } else {
    println("DRL compile: OK")
  }
  ks.newKieContainer(ks.getRepository.getDefaultReleaseId).getKieBase
}

val kieBase = buildKieBaseVerbose(drlBody)
println("KieBase OK")



%scala
import scala.collection.JavaConverters._
import CommonDataObject.{CommonDataModel, CommonDataResultSet}
import org.kie.api.runtime.rule.ClassObjectFilter

case class Out(indvId: Long, ruleNum: String, ruleFlag: Boolean, isActive: String)

def runRuleAndCollect(cdm: CommonDataModel): Seq[Out] = {
  val ksession: KieSession = kieBase.newKieSession()
  try {
    ksession.insert(cdm)
    ksession.fireAllRules()

    // collect all CommonDataResultSet inserted by the DRL
    val outObjs = ksession.getObjects(new ClassObjectFilter(classOf[CommonDataResultSet]))
      .asScala.toSeq.map(_.asInstanceOf[CommonDataResultSet])

    // adapt to your output table schema (IS_ACTIVE is 'Y'/'N' in Snowflake)
    outObjs.map { o =>
      Out(
        indvId    = Option(o.getIndv_id).map(_.toLong).getOrElse(0L),
        ruleNum   = Option(o.getStatus).getOrElse("NA"),         // or o.getRuleNum if you have that
        ruleFlag  = true,                                        // your DRL implies a positive flag
        isActive  = "Y"
      )
    }
  } finally {
    ksession.dispose()
  }
}





%scala
import java.sql.Date
import java.time.LocalDate

// helper to make a java.sql.Date easily
def d(s: String): Date = Date.valueOf(s)  // "YYYY-MM-DD"

// Create two CDM rows. Fill ONLY the fields your DRL actually reads.
// Everything else can stay null/default.
val fire = new CommonDataModel()  // assuming you added a public no-arg ctor
fire.setIndv_id(1001: java.lang.Integer)
fire.setElem_nbr(3327: java.lang.Integer)                 // matches your DRL "exists elem_nbr == 3327"
fire.setMem_name("INDV_ELEMENTS_ATTR_EG")                 // matches mem_name
fire.setContinuity("365D_Continuous")                     // used by your rule
fire.setEffective_date(d("2024-01-01"))
fire.setEnd_date(d("2024-12-31"))
fire.setDob(d("2010-06-15"))                              // if age logic is used
// set any other fields your DRL checks (e.g. others in `not`, dates, etc.)

val nofire = new CommonDataModel()
nofire.setIndv_id(1002: java.lang.Integer)
nofire.setElem_nbr(9999: java.lang.Integer)
nofire.setMem_name("SOMETHING_ELSE")
nofire.setContinuity("NON_CONTINUOUS")

val outs1 = runRuleAndCollect(fire)
val outs2 = runRuleAndCollect(nofire)

println("FIRE → " + outs1)
println("NOFIRE → " + outs2)
