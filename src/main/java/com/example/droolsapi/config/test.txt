import java.sql.Date
import org.kie.api.KieServices
import org.kie.api.builder.Message
import org.kie.api.io.ResourceType
import org.kie.internal.io.ResourceFactory
import org.kie.api.runtime.StatelessKieSession
import org.kie.internal.command.CommandFactory
import scala.collection.JavaConverters._
import CommonDataObject._

// === Load DRL ===
val rulePath = "dbfs:/FileStore/rules/AdolescentImmuneRule.drl"
val ks = KieServices.Factory.get
val kfs = ks.newKieFileSystem()
val body = dbutils.fs.head(rulePath)
kfs.write(rulePath, ResourceFactory.newByteArrayResource(body.getBytes("UTF-8")).setResourceType(ResourceType.DRL))
val kbuilder = ks.newKieBuilder(kfs).buildAll()
if (kbuilder.getResults.hasMessages(Message.Level.ERROR))
  throw new RuntimeException(kbuilder.getResults.getMessages.asScala.mkString("\n"))
val kbase = ks.newKieContainer(ks.getRepository.getDefaultReleaseId).getKieBase
val sess = kbase.newStatelessKieSession()
println("âœ… DRL loaded successfully\n")

// === Build test facts ===
val indv1 = 12345: java.lang.Integer
def factSetForAdolescent(indv: java.lang.Integer): Seq[CommonDataModel] = {
  val a = new CommonDataModel()
  a.setIndv_id(indv)
  a.setDob(Date.valueOf("2013-08-15"))
  a.setMin_eff_date(Date.valueOf("2023-01-01"))
  a.setFinal_end_date(Date.valueOf("2024-12-31"))
  a.setGrace_period(400: java.lang.Integer)

  val b = new CommonDataModel()
  b.setIndv_id(indv)
  b.setContinuity("365D_Continuous")
  b.setAdjustedFinalDate(400: java.lang.Integer)      // âœ… added
  b.setContinuousPeriod(400: java.lang.Integer)       // âœ… added

  val c = new CommonDataModel()
  c.setIndv_id(indv)
  c.setElem_nbr(3327: java.lang.Integer)
  c.setMem_name("INDV_ELEMENTS_ATTR_EG")
  c.setContinuity("365D_Continuous")

  Seq(a,b,c)
}

val testFacts = factSetForAdolescent(indv1)
println(s"ðŸ§© Created ${testFacts.size} test facts")

// === Execute Drools ===
val factObjects = new java.util.ArrayList[AnyRef]()
testFacts.foreach(f => factObjects.add(f.asInstanceOf[AnyRef]))

val insertCmd = CommandFactory.newInsertElements(factObjects)
val fireCmd   = CommandFactory.newFireAllRules()
val getCmd    = CommandFactory.newGetObjects("objects")
val batchCmds = new java.util.ArrayList[org.kie.api.command.Command[_]]()
batchCmds.add(insertCmd); batchCmds.add(fireCmd); batchCmds.add(getCmd)

val execResults = sess.execute(CommandFactory.newBatchExecution(batchCmds))
val allObjs = execResults.getValue("objects").asInstanceOf[java.util.List[AnyRef]]
if (allObjs == null) println("âš ï¸ No objects returned â€” rule might not have fired.")
else println(s"ðŸš€ Working memory contains ${allObjs.size()} objects after firing rules")

val resultSets = Option(allObjs)
  .map(_.asScala.collect { case r: CommonDataResultSet => r }.toSeq)
  .getOrElse(Seq.empty)

println(s"âœ¨ Inserted ${resultSets.size} CommonDataResultSet objects")
resultSets.foreach(r => println(s"âœ… RULE FIRED â†’ STATUS = ${r.getStatus}"))
