// =====================================================
// 6. INSERT FACTS, FIRE RULES, CAPTURE OUTPUT USING BATCH COMMAND
// =====================================================

import org.kie.internal.command.CommandFactory
import org.kie.api.command.Command
import scala.collection.JavaConverters._

// prepare java.util.ArrayList[AnyRef] of facts
val factObjects = new java.util.ArrayList[AnyRef]()
memberFacts.foreach(f => factObjects.add(f.asInstanceOf[AnyRef]))

// prepare Drools commands:
//   1. insert all facts
//   2. fire all rules
//   3. get all objects from working memory (and NAME it "objects")
val insertCmd     = CommandFactory.newInsertElements(factObjects)
val fireCmd       = CommandFactory.newFireAllRules()
val getObjectsCmd = CommandFactory.newGetObjects("objects")

val batchCmds = new java.util.ArrayList[Command[_]]()
batchCmds.add(insertCmd)
batchCmds.add(fireCmd)
batchCmds.add(getObjectsCmd)

// run the batch
val execResults = sess.execute(CommandFactory.newBatchExecution(batchCmds))

// âœ… now "objects" will exist in results
val allObjs = execResults.getValue("objects").asInstanceOf[java.util.List[AnyRef]]

if (allObjs == null) {
  println("âš ï¸ allObjs was null â€” no objects returned from Drools.")
} else {
  println(s"ðŸš€ Working memory after fireAllRules has ${allObjs.size()} objects")
}

// filter only CommonDataResultSet
val firedResults: Seq[CommonDataObject.CommonDataResultSet] =
  Option(allObjs)
    .map(_.asScala.collect {
      case r: CommonDataObject.CommonDataResultSet => r
    }.toSeq)
    .getOrElse(Seq.empty)

println(s"âœ¨ Rules inserted ${firedResults.size} CommonDataResultSet rows for INDV_ID=$targetIndvId")

// print rule statuses
firedResults.foreach(r => println(s" -> RULE HIT STATUS = ${r.getStatus()}"))

// global map
val resultMapAfter =
  sess.getGlobals.get("result").asInstanceOf[java.util.HashMap[String,Object]]

val ruleNum  = Option(resultMapAfter.get("ruleNum")).map(_.toString).getOrElse("NA")
val ruleFlag = Option(resultMapAfter.get("ruleFlag")).exists(_.toString.equalsIgnoreCase("true"))
val isActive = Option(resultMapAfter.get("isActive")).map(_.toString).getOrElse("Y")

println(s"ðŸŒ Global result map after run:")
println(s"    ruleNum  = $ruleNum")
println(s"    ruleFlag = $ruleFlag")
println(s"    isActive = $isActive")

// build final rows for Snowflake
case class OutRow(
  INDV_ID: Long,
  RULE_NUM: String,
  RULE_FLAG: Boolean,
  IS_ACTIVE: String
)

val outRowsFinal: Seq[OutRow] =
  firedResults.map(fr =>
    OutRow(
      INDV_ID   = targetIndvId,
      RULE_NUM  = Option(fr.getStatus()).getOrElse("NA"),
      RULE_FLAG = true,
      IS_ACTIVE = "Y"
    )
  )

println(s"ðŸ§¾ Final rows we would write back:")
outRowsFinal.foreach(println)

val finalDF =
  spark.createDataFrame(outRowsFinal)
    .withColumn("AUDIT_CREAT_DT", current_timestamp())

println("ðŸ“¦ finalDF preview:")
finalDF.show(false)
