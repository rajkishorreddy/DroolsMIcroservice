// =====================================================
// 6. Insert facts, fire rules, collect output
// =====================================================
memberFacts.foreach(sess.insert)

val fired = sess.fireAllRules()
println(s"ðŸ”¥ Fired $fired rules")

import org.kie.api.runtime.ClassObjectFilter

// grab all CommonDataResultSet objects from the KieSession
val rawResults: Seq[AnyRef] =
  sess.getObjects(new ClassObjectFilter(classOf[CommonDataObject.CommonDataResultSet]))
    .asScala
    .toSeq

println(s"âœ¨ Drools working memory returned ${rawResults.size} objects of type CommonDataResultSet (or similar)")

// cast them to the actual type so we can call getters
val typedResults: Seq[CommonDataObject.CommonDataResultSet] =
  rawResults.collect {
    case r: CommonDataObject.CommonDataResultSet => r
  }

println(s"âœ… After casting, we have ${typedResults.size} CommonDataResultSet rows for INDV_ID=$targetIndvId")

typedResults.foreach { r =>
  println(s" -> RULE HIT STATUS = ${r.getStatus()}")
}

// final case class for Snowflake output
case class OutRow(
  INDV_ID: Long,
  RULE_NUM: String,
  RULE_FLAG: Boolean,
  IS_ACTIVE: String
)

// build final output rows from typedResults
val outRowsFinal: Seq[OutRow] =
  typedResults.map { r =>
    OutRow(
      INDV_ID   = targetIndvId,
      RULE_NUM  = Option(r.getStatus()).getOrElse("NA"),
      RULE_FLAG = true,
      IS_ACTIVE = "Y"
    )
  }

println("ðŸ§¾ Final rows we would write back:")
outRowsFinal.foreach(println)

// turn into DF and add audit timestamp
val finalDF =
  spark.createDataFrame(outRowsFinal)
    .withColumn("AUDIT_CREAT_DT", current_timestamp())

println("ðŸ“¦ finalDF preview:")
finalDF.show(false)

// always dispose session at the end
sess.dispose()
