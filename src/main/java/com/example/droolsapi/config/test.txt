val grouped: Dataset[Seq[OutRow]] =
  factsDS
    .groupByKey(m => safeIndvId(m))(Encoders.scalaLong)
    .mapGroups { case (indvId, iterModels) =>
      // DEBUG PRINT INSIDE EXECUTOR
      println(s"ðŸ’¥ mapGroups firing for INDV_ID=$indvId")

      val batch = iterModels.toSeq

      println(s"   batch size for $indvId = ${batch.size}")
      batch.take(5).foreach { f =>
        println(s"   fact sample -> INDV_ID=${f.getIndv_id()}, ELEM_NBR=${f.getElem_nbr()}, CONTINUITY=${f.getContinuity()}")
      }

      // call our rule executor
      val outs = runRulesForOneMember(indvId, batch)

      println(s"   outs.size for $indvId = ${outs.size}")
      outs
    }(Encoders.kryo[Seq[OutRow]])

val allResultsDS =
  grouped.flatMap(rows => rows)(Encoders.product[OutRow])

println("=== DEBUG final collect ===")
val debugCollected = allResultsDS.collect()
println(s"total result rows from rules: ${debugCollected.length}")
debugCollected.take(20).foreach(println)
