%scala
import org.kie.api.KieServices
import org.kie.api.builder.{KieBuilder, Message, Results}
import org.kie.internal.io.ResourceFactory
import org.kie.api.runtime.rule.AgendaFilter
import org.kie.api.runtime.ClassObjectFilter
import org.kie.api.runtime.KieSession
import java.nio.charset.StandardCharsets
import java.sql.Date
import scala.collection.JavaConverters._
import CommonDataObject.{CommonDataModel, CommonDataResultSet}

// ---------- build KieSession (STATEFUL) from DBFS folder ----------
def buildStatefulSessionFromFolder(dirDbfs: String): KieSession = {
  val ks  = KieServices.Factory.get
  val kfs = ks.newKieFileSystem()
  val dirLocal = dirDbfs.replace("dbfs:/", "/dbfs/")

  val drlFiles = Option(new java.io.File(dirLocal).listFiles)
    .getOrElse(Array.empty)
    .filter(f => f.isFile && f.getName.endsWith(".drl"))

  println(s"ðŸ§© Found DRLs: ${drlFiles.map(_.getName).mkString(", ")}")

  drlFiles.foreach { f =>
    val body = scala.io.Source.fromFile(f, "UTF-8").mkString
    kfs.write(
      ResourceFactory
        .newByteArrayResource(body.getBytes(StandardCharsets.UTF_8))
        .setSourcePath(s"rules/${f.getName}")
    )
  }

  val kb: KieBuilder = KieServices.Factory.get.newKieBuilder(kfs).buildAll()
  val res: Results   = kb.getResults
  if (res.hasMessages(Message.Level.ERROR)) {
    println("âŒ DRL build errors:")
    res.getMessages(Message.Level.ERROR).forEach(m => println("  " + m))
    throw new IllegalStateException("DRL compile failed")
  }

  val kContainer = ks.newKieContainer(ks.getRepository.getDefaultReleaseId)
  val kbase = kContainer.getKieBase
  kbase.newKieSession()   // <<â€” STATEFUL
}

def d(s: String): java.sql.Date = Date.valueOf(s)

val ksession = buildStatefulSessionFromFolder("dbfs:/FileStore/rules")
println("âœ… Drools stateful session loaded")

// ---------- dummy facts ----------
val indv = 12345: java.lang.Integer

// Adolescent rule facts (a,b,c)
val a = new CommonDataModel()
a.setIndv_id(indv)
a.setDob(d("2013-08-15"))

val b = new CommonDataModel()
b.setIndv_id(indv)
b.setContinuity("365D_Continuous")
b.setEffective_date(d("2024-01-01"))
b.setMax_end_date(d("2023-12-31"))
b.setMin_eff_date(d("2023-01-01"))
b.setFinal_end_date(d("2024-12-31"))
b.setGrace_period(400: java.lang.Integer)

val c = new CommonDataModel()
c.setIndv_id(indv)
c.setElem_nbr(3327: java.lang.Integer)
c.setMem_name("INDV_ELEMENTS_ATTR_EG")
c.setContinuity("365D_Continuous")

// Asthma rule facts (p,q,r) â€” include if you want that rule to fire too
val p = new CommonDataModel()
p.setIndv_id(indv)
p.setAge(25: java.lang.Integer)
p.setElem_nbr(3018: java.lang.Integer)
p.setMem_name("INDV_ELEMENTS_ATTR_EG")

val q = new CommonDataModel()
q.setIndv_id(indv)
q.setElem_nbr(1125: java.lang.Integer)
q.setMem_name("INDV_ELEMENTS_EBM")

val r = new CommonDataModel()
r.setIndv_id(indv)
r.setElem_nbr(1021: java.lang.Integer)
r.setMem_name("INDV_ELEMENTS_ADJ")

// ---------- runner that returns CommonDataResultSet ----------
case class Out(indvId: Long, ruleNum: String, ruleFlag: Boolean, isActive: String)

def fireAndCollect(facts: Seq[CommonDataModel]): Seq[Out] = {
  try {
    // insert all facts
    facts.foreach(ksession.insert)
    val fired = ksession.fireAllRules()
    println(s"ðŸ”¥ Rules fired count: $fired")

    // collect inserted results
    val results = ksession.getObjects(new ClassObjectFilter(classOf[CommonDataResultSet]))
      .asScala
      .collect { case r: CommonDataResultSet =>
        Out(indv.longValue, Option(r.getStatus).getOrElse("NA"), true, "Y")
      }
      .toSeq
    results
  } finally {
    ksession.dispose()
  }
}

// ---------- choose which set you want to run ----------
val outs = fireAndCollect(Seq(a,b,c))               // only Adolescent
// val outs = fireAndCollect(Seq(a,b,c,p,q,r))      // Adolescent + Asthma

println("\nðŸš€ RULE EXECUTION RESULTS")
outs.foreach(o => println(s"â†’ INDV: ${o.indvId}, STATUS: ${o.ruleNum}, ACTIVE: ${o.isActive}"))
println(s"\nâœ… TOTAL RULES FIRED (collected): ${outs.size}")
