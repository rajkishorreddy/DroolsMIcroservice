// =========================================================
// ðŸ§ª Standalone Drools Rule Test in Databricks
// =========================================================

import org.kie.api.KieServices
import org.kie.api.builder.Message
import org.kie.api.io.ResourceType
import org.kie.internal.io.ResourceFactory
import org.kie.api.runtime.StatelessKieSession
import org.kie.internal.command.CommandFactory
import scala.collection.JavaConverters._

// Import your CommonDataObject classes
import CommonDataObject._

// =========================================================
// 1ï¸âƒ£ Load DRL file(s) from DBFS
// =========================================================
val rulePaths = Seq(
  "dbfs:/FileStore/rules/AdolescentImmuneRule.drl"  // change path if needed
)

val ks = KieServices.Factory.get
val kfs = ks.newKieFileSystem()

rulePaths.foreach { path =>
  val body = dbutils.fs.head(path)
  kfs.write(path, ResourceFactory.newByteArrayResource(body.getBytes("UTF-8")).setResourceType(ResourceType.DRL))
}

val kbuilder = ks.newKieBuilder(kfs).buildAll()
val results = kbuilder.getResults
if (results.hasMessages(Message.Level.ERROR)) {
  throw new IllegalStateException("ðŸ”¥ Drools build error:\n" + results.getMessages.asScala.mkString("\n"))
}

val kbase = ks.newKieContainer(ks.getRepository.getDefaultReleaseId).getKieBase
val sess: StatelessKieSession = kbase.newStatelessKieSession()

println("âœ… DRL loaded successfully\n")

// =========================================================
// 2ï¸âƒ£ Build guaranteed test facts to trigger AdolescentImmuneRule
// =========================================================
val testFacts = Seq(
  {
    val m = new CommonDataModel()
    m.setIndv_id(99999)
    m.setElem_nbr(3327)
    m.setMem_name("INDV_ELEMENTS_ATTR_EG")
    m.setAgeInDecimals(true)
    m.setAdjustedFinalDate(400)
    m.setContinuity("365D_Continuous")
    m.setContinuousPeriod(400)
    m
  },
  {
    val m = new CommonDataModel()
    m.setIndv_id(99999)
    m.setElem_nbr(9999)
    m.setMem_name("RANDOM_ELEM")
    m.setAgeInDecimals(true)
    m.setAdjustedFinalDate(100)
    m.setContinuity("365D_Continuous")
    m.setContinuousPeriod(100)
    m
  }
)

println(s"ðŸ§© Created ${testFacts.size} test facts")

// =========================================================
// 3ï¸âƒ£ Run rules using BatchExecution
// =========================================================
val factObjects = new java.util.ArrayList[AnyRef]()
testFacts.foreach(f => factObjects.add(f.asInstanceOf[AnyRef]))

val insertCmd     = CommandFactory.newInsertElements(factObjects)
val fireCmd       = CommandFactory.newFireAllRules()
val getObjectsCmd = CommandFactory.newGetObjects("objects")

val batchCmds = new java.util.ArrayList[org.kie.api.command.Command[_]]()
batchCmds.add(insertCmd)
batchCmds.add(fireCmd)
batchCmds.add(getObjectsCmd)

val execResults = sess.execute(CommandFactory.newBatchExecution(batchCmds))

// =========================================================
// 4ï¸âƒ£ Inspect results
// =========================================================
val allObjs = execResults.getValue("objects").asInstanceOf[java.util.List[AnyRef]]

if (allObjs == null) {
  println("âš ï¸ No objects returned â€” rule might not have fired.")
} else {
  println(s"ðŸš€ Working memory contains ${allObjs.size()} objects after firing rules")
}

val resultSets = Option(allObjs)
  .map(_.asScala.collect { case r: CommonDataResultSet => r }.toSeq)
  .getOrElse(Seq.empty)

println(s"âœ¨ Inserted ${resultSets.size} CommonDataResultSet objects")

resultSets.foreach { r =>
  println(s"âœ… RULE FIRED â†’ STATUS = ${r.getStatus}")
}
