<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.example</groupId>
  <artifactId>drools-bridge</artifactId>
  <version>1.0.0</version>

  <properties>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
    <!-- Use a stable 7.x that supports Java 8 -->
    <drools.version>7.74.1.Final</drools.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.drools</groupId>
      <artifactId>drools-core</artifactId>
      <version>${drools.version}</version>
    </dependency>
    <dependency>
      <groupId>org.drools</groupId>
      <artifactId>drools-compiler</artifactId>
      <version>${drools.version}</version>
    </dependency>
    <dependency>
      <groupId>org.kie</groupId>
      <artifactId>kie-api</artifactId>
      <version>${drools.version}</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <!-- Build an uber-jar so executors have everything -->
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-shade-plugin</artifactId>
        <version>3.5.1</version>
        <executions>
          <execution>
            <phase>package</phase>
            <goals><goal>shade</goal></goals>
            <configuration>
              <createDependencyReducedPom>false</createDependencyReducedPom>
              <filters>
                <filter>
                  <artifact>*:*</artifact>
                  <excludes>
                    <exclude>META-INF/*.SF</exclude>
                    <exclude>META-INF/*.DSA</exclude>
                    <exclude>META-INF/*.RSA</exclude>
                  </excludes>
                </filter>
              </filters>
            </configuration>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
</project>








package com.example;

import org.kie.api.KieServices;
import org.kie.api.builder.KieBuilder;
import org.kie.api.builder.KieFileSystem;
import org.kie.api.builder.Message;
import org.kie.api.builder.Results;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.StatelessKieSession;
import org.kie.internal.io.ResourceFactory;

import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Java 8â€“compatible bridge for Drools 7.x.
 * Compile DRLs once per executor (cached), execute per row.
 */
public class DroolsBridge {

    private static final Map<String, StatelessKieSession> SESSION_CACHE = new ConcurrentHashMap<String, StatelessKieSession>();

    public static synchronized String loadBundle(String bundleId, List<String> drlBodies) {
        if (SESSION_CACHE.containsKey(bundleId)) return "OK(CACHED)";

        KieServices ks = KieServices.Factory.get();
        KieFileSystem kfs = ks.newKieFileSystem();

        int idx = 0;
        for (String body : drlBodies) {
            kfs.write(
                ResourceFactory.newByteArrayResource(body.getBytes(StandardCharsets.UTF_8))
                               .setSourcePath("rules/rule_" + (idx++) + ".drl")
            );
        }

        KieBuilder kb = ks.newKieBuilder(kfs).buildAll();
        Results results = kb.getResults();
        if (results.hasMessages(Message.Level.ERROR)) {
            throw new IllegalStateException("Drools build errors: " + results.getMessages(Message.Level.ERROR));
        }

        KieContainer kc = ks.newKieContainer(ks.getRepository().getDefaultReleaseId());
        StatelessKieSession stateless = kc.getKieBase().newStatelessKieSession();
        SESSION_CACHE.put(bundleId, stateless);
        return "OK";
    }

    public static Map<String, Object> exec(String bundleId, Map<String, Object> fact) {
        StatelessKieSession s = SESSION_CACHE.get(bundleId);
        if (s == null) {
            throw new IllegalStateException("No session for bundleId=" + bundleId + ". Call loadBundle() first.");
        }
        Map<String, Object> result = new HashMap<String, Object>();
        s.setGlobal("result", result);

        ArrayList<Object> facts = new ArrayList<Object>();
        facts.add(fact);
        facts.add(result); // optional: rules can also mutate this

        s.execute(facts);
        return result;
    }
}





from pyspark.sql import functions as F, types as T
import hashlib, os

# 1) Read DRLs from DBFS
drl_dir = "/dbfs/FileStore/rules"
drl_bodies = []
for fn in os.listdir(drl_dir):
    if fn.endswith(".drl"):
        with open(os.path.join(drl_dir, fn), "r", encoding="utf-8") as f:
            drl_bodies.append(f.read())

# 2) Bundle id (so executors cache per ruleset)
bundle_id = hashlib.sha1(("".join(sorted(drl_bodies))).encode("utf-8")).hexdigest()

# 3) Ensure the bridge class is visible
jvm = spark._jvm
Bridge = jvm.com.example.DroolsBridge

# 4) Compile/cached per executor JVM
spark.range(1).rdd.foreachPartition(lambda _: Bridge.loadBundle(bundle_id, drl_bodies))

# 5) Demo DF
schema = T.StructType([
    T.StructField("indvId", T.LongType(), False),
    T.StructField("attrA",  T.StringType(), True),
    T.StructField("amount", T.DoubleType(), True),
])
df = spark.createDataFrame([
    (101, "X", 500.0),
    (102, "Y", 1200.5),
    (103, "X", 50.0),
], schema)

# 6) UDF that calls Drools (session reused via bundle_id)
@F.udf(T.StructType([
    T.StructField("ruleNum",  T.StringType(), True),
    T.StructField("ruleFlag", T.StringType(), True),
    T.StructField("isActive", T.BooleanType(), True),
]))
def run_rules(indvId, attrA, amount):
    m = {
        "indvId": int(indvId) if indvId is not None else None,
        "attrA": attrA,
        "amount": float(amount) if amount is not None else None
    }
    res = Bridge.exec(bundle_id, m)  # java.util.Map -> Py4J-mappable
    return {
        "ruleNum":  res.get("ruleNum") if res else None,
        "ruleFlag": res.get("ruleFlag") if res else None,
        "isActive": bool(res.get("isActive")) if res and res.get("isActive") is not None else False
    }

out = df.withColumn("res", run_rules("indvId","attrA","amount")) \
        .select("indvId",
                F.col("res.ruleNum").alias("ruleNum"),
                F.col("res.ruleFlag").alias("ruleFlag"),
                F.col("res.isActive").alias("isActive"))

out.show(truncate=False)
