// ==========================================================
// 3ï¸âƒ£ FIXED DEBUG EXECUTION BLOCK (StatelessKieSession + GetObjects)
// ==========================================================
import scala.collection.JavaConverters._
import java.util.{ArrayList, Collection}
import org.kie.api.command.Command
import org.kie.internal.command.CommandFactory

def runRulesForOneMember_localDebug(indvId: Long, facts: Seq[CommonDataObject.CommonDataModel]): Seq[OutRow] = {
  println(s"ðŸ’¥ Running Drools for INDV_ID=$indvId with ${facts.size} facts")

  val sess: org.kie.api.runtime.StatelessKieSession = buildSessionFromBundle(ruleBundleBC.value)

  // === build fact list
  val factObjects: java.util.ArrayList[AnyRef] = new java.util.ArrayList[AnyRef]()
  facts.foreach(f => factObjects.add(f.asInstanceOf[AnyRef]))

  // === batch commands (insert + fire + get objects)
  val insertCmd = CommandFactory.newInsertElements(factObjects)
  val fireCmd = CommandFactory.newFireAllRules()
  val getObjectsCmd = CommandFactory.newGetObjects() // retrieves all inserted facts
  val batchCmds = new java.util.ArrayList[Command[_]]()
  batchCmds.add(insertCmd)
  batchCmds.add(fireCmd)
  batchCmds.add(getObjectsCmd)

  // === execute Drools session
  val execResults = sess.execute(CommandFactory.newBatchExecution(batchCmds))

  // === extract facts (like CommonDataResultSet)
  val droolsResultObjects = execResults.getValue("objects").asInstanceOf[java.util.List[AnyRef]]

  val outs: Seq[OutRow] = droolsResultObjects.asScala.collect {
    case r: CommonDataObject.CommonDataResultSet =>
      val ruleNum = Option(r.getStatus()).getOrElse("NA")
      OutRow(
        INDV_ID = indvId,
        RULE_NUM = ruleNum,
        RULE_FLAG = true,
        IS_ACTIVE = "Y"
      )
  }.toSeq

  println(s"-> Drools produced ${outs.size} result rows for $indvId")
  outs.foreach(o => println(s"RESULT: $o"))
  outs
}
