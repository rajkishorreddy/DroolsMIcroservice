from pyspark.sql import functions as F
from pyspark.sql.window import Window

# ========= 0) Load table (adjust options/dbtable for your env) =========
# df should have at least these columns:
# INDV_ID, AGE, ELEM_NBR, MEM_NAME, ELEM_QTY, ELEM_SUP, CONTINUITY,
# CONTINUOUS_PERIOD, EFFECTIVE_DATE, MAX_END_DATE, FINAL_END_DATE, MIN_EFF_DATE,
# ELEM_DT_1, ELEM_DT_2
df = (
    spark.read.format("snowflake")
    .options(**snowflake_options)
    .option("dbtable", "ELEMENT_DATA_TABLE_KIS")   # <--- change if needed
    .load()
    .select(
        "INDV_ID","AGE","ELEM_NBR","MEM_NAME","ELEM_QTY","ELEM_SUP",
        "CONTINUITY","CONTINUOUS_PERIOD",
        "EFFECTIVE_DATE","MAX_END_DATE","FINAL_END_DATE","MIN_EFF_DATE",
        "ELEM_DT_1","ELEM_DT_2"
    )
)

# ========= 1) Derived columns (mirror your Java getters) =========

# 1a) PDC numerator in days (getPdcNumeratorInDays)
# Java: if elem_sup prefix[0..7) == "PHARM 2", take substring(15,18) -> Spark: (start=16, len=3)
pdc_base = F.when(
    (F.col("ELEM_SUP").isNotNull()) & (F.length("ELEM_SUP") > 18) &
    (F.substring("ELEM_SUP", 1, 7) == F.lit("PHARM 2")),
    F.substring("ELEM_SUP", 16, 3)
)
pdc_digits = F.regexp_replace(pdc_base, r"[^0-9-]", "")
df = df.withColumn(
    "PDC_NUMERATOR_IN_DAYS",
    F.when(F.length(pdc_digits) > 0, pdc_digits.cast("int"))
)

# 1b) Adjusted final date (getAdjustedFinalDate)
df = df.withColumn(
    "ADJUSTED_FINAL_DATE",
    F.when(
        F.col("EFFECTIVE_DATE").isNotNull() &
        F.col("MAX_END_DATE").isNotNull() &
        (F.col("EFFECTIVE_DATE") > F.col("MAX_END_DATE")) &
        F.col("FINAL_END_DATE").isNotNull() &
        F.col("MIN_EFF_DATE").isNotNull(),
        F.datediff(F.col("FINAL_END_DATE"), F.col("MIN_EFF_DATE"))
    )
)

# 1c) isElemDt2XDays (getIsElemDt2XDays)
today_minus_43 = F.date_sub(F.current_date(), 43)
df = df.withColumn(
    "IS_ELEM_DT_2X_DAYS",
    F.when(F.col("ELEM_DT_2").isNotNull(), F.datediff(today_minus_43, F.to_date("ELEM_DT_2")))
)

# ========= 2) Feature flags per INDV_ID (EXISTS/NOT EXISTS in one agg) =========
feat = (
    df.groupBy("INDV_ID").agg(
        # $sdm: age ∈ [6,12)
        F.max(F.when((F.col("AGE") >= 6) & (F.col("AGE") < 12), 1).otherwise(0)).alias("sdm_exists"),

        # $pharm exists: elem_nbr = 2563, PHARM, PDC >= 210
        F.max(F.when(
            (F.col("ELEM_NBR") == 2563) &
            (F.col("MEM_NAME") == "INDV_ELEMENTS_PHARM") &
            (F.col("PDC_NUMERATOR_IN_DAYS") >= 210),
            1).otherwise(0)
        ).alias("pharm_exists"),

        # continuity gate: (continuousPeriod>=320 && "3650_Continuous") OR (adjustedFinalDate>=320 && "3650_Continuous")
        F.max(F.when(
            ((F.col("CONTINUOUS_PERIOD") >= 320) & (F.col("CONTINUITY") == "3650_Continuous")) |
            ((F.col("ADJUSTED_FINAL_DATE") >= 320) & (F.col("CONTINUITY") == "3650_Continuous")),
            1).otherwise(0)
        ).alias("has_continuous_condition"),

        # must have 3018 + ATTR_EG
        F.max(F.when(
            (F.col("ELEM_NBR") == 3018) & (F.col("MEM_NAME") == "INDV_ELEMENTS_ATTR_EG"),
            1).otherwise(0)
        ).alias("has_3018_ATTR_EG"),

        # forbid ADJ/PREADJ in last 365 days via dt2
        F.max(F.when(
            (
                ((F.col("ELEM_NBR") == 2575) & (F.col("MEM_NAME") == "INDV_ELEMENTS_ADJ")) |
                ((F.col("ELEM_NBR") == 2576) & (F.col("MEM_NAME") == "INDV_ELEMENTS_PREADJ"))
            ) & (F.col("IS_ELEM_DT_2X_DAYS") >= 0) & (F.col("IS_ELEM_DT_2X_DAYS") <= 365),
            1).otherwise(0)
        ).alias("has_forbidden_adj_preadj"),

        # forbid ATTR_EG in set {3048, 3159, 3010}
        F.max(F.when(
            (F.col("MEM_NAME") == "INDV_ELEMENTS_ATTR_EG") & (F.col("ELEM_NBR").isin(3048, 3159, 3010)),
            1).otherwise(0)
        ).alias("has_forbidden_attr_eg_set")
    )
)

# ========= 3) Choose one $pharm row per INDV_ID (to read elem_sup in THEN) =========
pharm_rows = df.filter(
    (F.col("ELEM_NBR") == 2563) &
    (F.col("MEM_NAME") == "INDV_ELEMENTS_PHARM") &
    (F.col("PDC_NUMERATOR_IN_DAYS") >= 210)
).select("INDV_ID", "ELEM_SUP")

# Prefer ELEM_SUP starting "PHARM 2"; tie-break by longest string
pharm_ranked = (
    pharm_rows
    .withColumn("is_pharm2", F.col("ELEM_SUP").startswith("PHARM 2").cast("int"))
    .withColumn("len_sup", F.length("ELEM_SUP"))
)
w = Window.partitionBy("INDV_ID").orderBy(F.col("is_pharm2").desc(), F.col("len_sup").desc())
pharm_one = (
    pharm_ranked
    .withColumn("rn", F.row_number().over(w))
    .filter("rn = 1")
    .drop("rn", "is_pharm2", "len_sup")
)

# ========= 4) THEN block – implement exactly like your Java =========
# Conditions: elem_sup != null, startsWith("PHARM 2")
startsWithPharm2 = F.col("ELEM_SUP").isNotNull() & F.col("ELEM_SUP").startswith("PHARM 2")
len_ge_152 = (F.length("ELEM_SUP") >= 152)
len_ge_131 = (F.length("ELEM_SUP") >= 131)

# Java substring(a,b) -> Spark substring(a+1, b-a)
# (93,103) -> (94,10) ; (115,125) -> (116,10) ; single-char flags: (114,115)->(115,1), (130,131)->(131,1)
s93_103  = F.substring("ELEM_SUP", 94, 10)
s115_125 = F.substring("ELEM_SUP", 116, 10)

# numeric conversions (keep null if not digits)
to_num = lambda s: F.when(F.length(F.regexp_replace(s, r"[^0-9.-]", "")) > 0,
                          F.regexp_replace(s, r"[^0-9.-]", "").cast("double"))

score1Desc = F.when(len_ge_152, F.lit("RXMD"))
score1Nbr  = F.when(len_ge_152, to_num(s93_103))

flag115 = F.when(len_ge_131, F.substring("ELEM_SUP", 115, 1))
flag131 = F.when(len_ge_131, F.substring("ELEM_SUP", 131, 1))

# score2/score3 according to your nested if/else:
# if (flag115 == "")
#    score2Desc="MXRXMD"; score2Nbr = substring(93,103)
# else if (flag115 == "B")
#    score3Desc="BHRXMD"; score3Nbr = substring(93,103)
# else {
#    if (flag131 == "")
#        score2Desc="MXRXMD"; score2Nbr = substring(115,125)
#    else if (flag131 == "B")
#        score3Desc="BHRXMD"; score3Nbr = substring(115,125)
# }
empty = F.lit("")

score2Desc = F.when(flag115 == empty, F.lit("MXRXMD")) \
              .when((flag115.isNotNull()) & (flag115 != empty) & (flag115 != F.lit("B")) & (flag131 == empty), F.lit("MXRXMD"))

score2Nbr  = F.when(flag115 == empty, to_num(s93_103)) \
              .when((flag115.isNotNull()) & (flag115 != empty) & (flag115 != F.lit("B")) & (flag131 == empty), to_num(s115_125))

score3Desc = F.when(flag115 == F.lit("B"), F.lit("BHRXMD")) \
              .when((flag115.isNotNull()) & (flag115 != empty) & (flag115 != F.lit("B")) & (flag131 == F.lit("B")), F.lit("BHRXMD"))

score3Nbr  = F.when(flag115 == F.lit("B"), to_num(s93_103)) \
              .when((flag115.isNotNull()) & (flag115 != empty) & (flag115 != F.lit("B")) & (flag131 == F.lit("B")), to_num(s115_125))

then_cols = (
    pharm_one
    .withColumn("startsWithPharm2", startsWithPharm2)
    .withColumn("score1Desc", score1Desc)
    .withColumn("score1Nbr",  score1Nbr)
    .withColumn("score2Desc", score2Desc)
    .withColumn("score2Nbr",  score2Nbr)
    .withColumn("score3Desc", score3Desc)
    .withColumn("score3Nbr",  score3Nbr)
    .select("INDV_ID","startsWithPharm2","score1Desc","score1Nbr","score2Desc","score2Nbr","score3Desc","score3Nbr")
)

# ========= 5) Rule gates (ALL must hold) =========
rule_pass = (
    (F.col("sdm_exists") == 1) &
    (F.col("pharm_exists") == 1) &
    (F.col("has_continuous_condition") == 1) &
    (F.col("has_3018_ATTR_EG") == 1) &
    (F.col("has_forbidden_adj_preadj") == 0) &
    (F.col("has_forbidden_attr_eg_set") == 0)
)

# ========= 6) Build final STATUS exactly like DRL (with "null" text for missing) =========
joined = feat.join(then_cols, on="INDV_ID", how="left")

# helpers to print "null" when the value is null
s = lambda c: F.when(F.col(c).isNotNull(), F.col(c).cast("string")).otherwise(F.lit("null"))

status = F.concat_ws(
    "",
    F.lit("TPOBEH001; "),
    s("score1Desc"), F.lit(" ; "), s("score1Nbr"),  F.lit(" ; "),
    s("score2Desc"), F.lit(" ; "), s("score2Nbr"),  F.lit(" ; "),
    s("score3Desc"), F.lit(" ; "), s("score3Nbr")
)

result = (
    joined
    .filter(rule_pass & F.col("startsWithPharm2"))
    .select("INDV_ID", status.alias("STATUS"))
)

result.show(50, truncate=False)
